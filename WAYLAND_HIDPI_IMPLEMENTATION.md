# RGFW Wayland HiDPI Scale Reporting - Implementation Guide

This document provides the exact code changes needed to add proper HiDPI scale reporting to RGFW on Wayland.

## Summary
Add fractional-scale-v1 protocol support to RGFW so applications can:
1. Query the current HiDPI scale factor (e.g., 3.0x on your display)
2. Receive callbacks when scale changes (moving window between displays)
3. Create properly sized swapchains/framebuffers (logical_size * scale = pixel_size)

## Required Protocol Files
Already generated by build-native.sh:
- `fractional-scale-v1.h` / `fractional-scale-v1.c`
- `viewporter.h` / `viewporter.c`

---

## Code Changes to RGFW.h

### 1. Add protocol includes (after line 7819)

```c
#include "xdg-output-unstable-v1.h"
#include "fractional-scale-v1.h"    // ADD THIS
#include "viewporter.h"              // ADD THIS
```

### 2. Add scale fields to RGFW_window struct (around line 2920)

Find:
```c
struct RGFW_window {
	RGFW_window_src src;
	RGFW_windowInternal internal;
	void* userPtr;
	i32 x, y, w, h;
};
```

Change to:
```c
struct RGFW_window {
	RGFW_window_src src;
	RGFW_windowInternal internal;
	void* userPtr;
	i32 x, y, w, h;
	float scaleX, scaleY;  // HiDPI scale factors (1.0 = no scaling, 3.0 = 3x scaling)
};
```

### 3. Add fractional scale manager to RGFW_info (around line 2967)

Find the Wayland-specific section in `struct RGFW_info`:
```c
#ifdef RGFW_WAYLAND
	struct wl_display* wl_display;
	struct wl_compositor* compositor;
	// ... other Wayland globals ...
```

Add after the existing Wayland globals:
```c
	struct wp_fractional_scale_manager_v1* fractional_scale_manager;
	struct wp_viewporter* viewporter;
```

### 4. Add fractional scale object to RGFW_window_src (find the Wayland typedef around line 2500)

Find:
```c
#ifdef RGFW_WAYLAND
typedef struct RGFW_window_src {
	struct wl_surface* surface;
	struct xdg_surface* xdg_surface;
	struct xdg_toplevel* xdg_toplevel;
	// ... other fields ...
```

Add:
```c
	struct wp_fractional_scale_v1* fractional_scale;
	struct wp_viewport* viewport;
```

### 5. Add fractional scale listener (after line 7820, before other listeners)

```c
// Fractional scale listener for HiDPI support
static void fractional_scale_preferred_scale(
	void* data,
	struct wp_fractional_scale_v1* fractional_scale,
	uint32_t scale_120)
{
	RGFW_UNUSED(fractional_scale);
	RGFW_window* win = (RGFW_window*)data;
	if (!win) return;
	
	// fractional-scale-v1 protocol uses fixed-point: scale * 120
	// e.g., 3.0x scale = 360, 1.5x scale = 180
	float scale = scale_120 / 120.0f;
	
	RGFW_INFO(2, 14, "Scale update received: %.2fx (was %.2fx)", scale, win->scaleX);
	
	if (win->scaleX != scale || win->scaleY != scale) {
		win->scaleX = win->scaleY = scale;
		RGFW_scaleUpdatedCallback(win, scale, scale);
	}
}

static const struct wp_fractional_scale_v1_listener fractional_scale_listener = {
	.preferred_scale = fractional_scale_preferred_scale,
};
```

### 6. Register protocols in registry listener (around line 8050)

Find the `registry_global` function and add these cases:

```c
static void registry_global(void* data, struct wl_registry* registry,
							u32 name, const char* interface, u32 version) {
	RGFW_UNUSED(data); RGFW_UNUSED(version);
	
	// ... existing protocol bindings ...
	
	else if (strcmp(interface, wp_fractional_scale_manager_v1_interface.name) == 0) {
		_RGFW->fractional_scale_manager = wl_registry_bind(
			registry, name, &wp_fractional_scale_manager_v1_interface, 1);
		RGFW_INFO(2, 14, "Bound fractional scale manager v1");
	}
	else if (strcmp(interface, wp_viewporter_interface.name) == 0) {
		_RGFW->viewporter = wl_registry_bind(
			registry, name, &wp_viewporter_interface, 1);
		RGFW_INFO(2, 14, "Bound viewporter");
	}
}
```

### 7. Initialize scale in window creation (in RGFW_createWindowPlatform, after wl_surface creation)

Find where `win->src.surface` is created (around line 8300) and add after it:

```c
	// Initialize scale to 1.0 (will be updated by fractional-scale callback)
	win->scaleX = 1.0f;
	win->scaleY = 1.0f;
	
	// Request fractional scale updates for HiDPI support
	if (_RGFW->fractional_scale_manager) {
		win->src.fractional_scale = wp_fractional_scale_manager_v1_get_fractional_scale(
			_RGFW->fractional_scale_manager,
			win->src.surface
		);
		if (win->src.fractional_scale) {
			wp_fractional_scale_v1_add_listener(
				win->src.fractional_scale,
				&fractional_scale_listener,
				win
			);
			RGFW_INFO(2, 14, "Fractional scale listener registered");
		}
	}
	
	// Create viewport for scaling
	if (_RGFW->viewporter) {
		win->src.viewport = wp_viewporter_get_viewport(
			_RGFW->viewporter,
			win->src.surface
		);
		if (win->src.viewport) {
			RGFW_INFO(2, 14, "Viewport created for surface");
		}
	}
```

### 8. Clean up scale objects in window close (in RGFW_window_closePlatform)

Find the Wayland cleanup section (around line 9000) and add before other cleanups:

```c
#ifdef RGFW_WAYLAND
	if (win->src.fractional_scale) {
		wp_fractional_scale_v1_destroy(win->src.fractional_scale);
		win->src.fractional_scale = NULL;
	}
	if (win->src.viewport) {
		wp_viewport_destroy(win->src.viewport);
		win->src.viewport = NULL;
	}
#endif
```

### 9. Clean up global managers in RGFW_init_ptr reset (around line 7900)

Find where Wayland globals are destroyed and add:

```c
	if (_RGFW->fractional_scale_manager) {
		wp_fractional_scale_manager_v1_destroy(_RGFW->fractional_scale_manager);
		_RGFW->fractional_scale_manager = NULL;
	}
	if (_RGFW->viewporter) {
		wp_viewporter_destroy(_RGFW->viewporter);
		_RGFW->viewporter = NULL;
	}
```

---

## Testing

After making these changes:

1. Rebuild RGFW:
```bash
cd /home/jjzazuet/code/ujgl-native
./ul-gfx-native/scripts/build-native.sh
```

2. Run a test program and check logs:
```bash
cd /home/jjzazuet/code/rd0lx
gradle :rz-spec:test --tests "RzSwapchainTest"
```

Expected output:
```
RGFW INFO (2 14): Fractional scale listener registered
RGFW INFO (2 14): Scale update received: 3.00x (was 1.00x)
```

3. Verify in Java:
The `onScaleUpdated` callback should now fire with (3.0, 3.0) on your HiDPI display.

4. Create properly sized swapchains:
```java
int framebufferWidth = Math.round(logicalWidth * scaleX);
int framebufferHeight = Math.round(logicalHeight * scaleY);
```

---

## Benefits

✅ **No more blurry rendering** - Swapchains will be created at correct pixel dimensions
✅ **Automatic scale detection** - Works on any HiDPI Wayland compositor
✅ **Multi-monitor support** - Scale updates when moving windows between displays
✅ **Matches GLFW behavior** - Compatible with `glfwGetWindowContentScale()`
✅ **Modern protocol** - Uses fractional-scale-v1 for precise scaling (1.25x, 1.5x, 2.0x, 3.0x, etc.)

---

## Fallback Behavior

If fractional-scale-v1 is not available (older compositors):
- Scale defaults to 1.0 (no scaling)
- Applications can still manually query output scale via wl_output (integer only)
- Future: Could add preferred_buffer_scale as fallback (Wayland core protocol)

---

## Compositor Support

- **GNOME/Mutter 43+**: ✅ Full support
- **KDE Plasma 5.27+**: ✅ Full support  
- **Sway/wlroots 0.16+**: ✅ Full support
- **Older compositors**: Falls back to 1.0x scale (no HiDPI)
